generator client {
  provider   = "prisma-client-js"
  output     = "../lib/generated/prisma"
  engineType = "binary"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id              String            @id @unique @default(uuid())
  email           String            @unique
  name            String
  playlists       Playlist[]
  kindeId         String            @unique
  PracticeSession PracticeSession[]
  UserStats       UserStats?
  UserSettings    UserSettings?
    timerSets TimerSet[]
}

model Playlist {
  id        String         @id @unique @default(uuid())
  name      String
  createdAt DateTime       @default(now())
  user      User           @relation(fields: [userId], references: [id])
  userId    String
  songs     PlaylistSong[]
}

model Song {
  id           String         @id @unique @default(uuid())
  spotifyUri   String         @unique
  getSongBpmId String         @unique
  title        String
  uri          String
  tempo        Int
  artist       String
  duration     Int?
  genres       String[]
  playlists    PlaylistSong[]
}

model PlaylistSong {
  playlist   Playlist @relation(fields: [playlistId], references: [id], onDelete: Cascade)
  playlistId String

  song   Song   @relation(fields: [songId], references: [id], onDelete: Cascade)
  songId String @default(uuid())

  addedAt DateTime @default(now())

  @@id([playlistId, songId])
}

model PracticeSession {
  id        String          @id @default(uuid())
  user      User            @relation(fields: [userId], references: [id])
  userId    String
  createdAt DateTime        @default(now())
  gameType  String
  duration  Int
  result    PracticeResult? @relation(fields: [resultId], references: [id])
  resultId  String?

  events PracticeEvent[]
}

model PracticeEvent {
  id        String          @id @default(uuid())
  session   PracticeSession @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  sessionId String

  expectedNote      String
  playedNote        String?
  isCorrect         Boolean
  playedAt          DateTime
  timeToHitMs       Int?
  metronomeOffsetMs Int?
}

model PracticeResult {
  id               String            @id @default(uuid())
  totalNotes       Int
  correctNotes     Int
  averageHitTimeMs Int?
  rhythmAccuracy   Float?
  score            Int
  PracticeSession  PracticeSession[]
}

model UserStats {
  id            String   @id @default(uuid())
  user          User     @relation(fields: [userId], references: [id])
  userId        String   @unique
  totalSessions Int
  totalTime     DateTime // seconds
  avgScore      Float
  totalScore    Int
  lastPracticed DateTime
}

model UserSettings {
  id                   String  @id @default(cuid())
  userId               String  @unique
  latency              Int?
  defaultInputDeviceId String?
  completed            Boolean @default(false)

  user User @relation(fields: [userId], references: [id])
}

model TimerSet {
  id        String   @id @default(cuid())
  name      String   @default("Untitled Set")
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userId    String
  user      User     @relation(fields: [userId], references: [id])
  phases    Phase[]
}

model Phase {
  id              String   @id @default(cuid())
  initialDuration Int      // in ms
  bpm             Int
  label           String
  postCooldown    Int
  order           Int      // ensures correct ordering
  timerSetId      String
  timerSet        TimerSet @relation(fields: [timerSetId], references: [id], onDelete: Cascade)
  autoStart Boolean @default(false)
}